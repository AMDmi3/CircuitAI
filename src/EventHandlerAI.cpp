/* This file is part of the Spring engine (GPL v2 or later), see LICENSE.html */

#include "EventHandlerAI.h"
#include "circuit/CircuitUnit.h"
#include "circuit/utils.h"

// generated by the C++ Wrapper scripts
#include "OOAICallback.h"
#include "Log.h"

namespace eventhandlerai {

using namespace circuit;

CEventHandlerAI::CEventHandlerAI(springai::OOAICallback* callback) :
		callback(callback),
		skirmishAIId(callback != NULL ? callback->GetSkirmishAIId() : -1)
{
	circuit = new CCircuit(callback);
}

CEventHandlerAI::~CEventHandlerAI()
{
	delete circuit;
}

//#define DEBUG
//#if 1
#ifdef DEBUG
	#define PRINT_TOPIC(txt, topic)	\
		std::string msgText = std::string("<CircuitAI> ") + txt + " topic: " + utils::int_to_string(topic) + ", SkirmishAIId: " + utils::int_to_string(callback->GetSkirmishAIId());	\
		springai::Log* log = callback->GetLog();	\
		log->DoLog(msgText.c_str());	\
		delete log
#else
	#define PRINT_TOPIC(txt, topic)
#endif

int CEventHandlerAI::HandleEvent(int topic, const void* data)
{
	int ret = ERROR_UNKNOWN;

	switch (topic) {
		case EVENT_INIT: {
			PRINT_TOPIC("EVENT_INIT", topic);
			struct SInitEvent* evt = (struct SInitEvent*)data;
			ret = circuit->Init(evt->skirmishAIId, evt->callback);
			break;
		}
		case EVENT_RELEASE: {
			PRINT_TOPIC("EVENT_RELEASE", topic);
			struct SReleaseEvent* evt = (struct SReleaseEvent*)data;
			ret = circuit->Release(evt->reason);
			break;
		}
		case EVENT_UPDATE: {
//			PRINT_TOPIC("EVENT_UPDATE", topic);
			struct SUpdateEvent* evt = (struct SUpdateEvent*)data;
			ret = circuit->Update(evt->frame);
			break;
		}
		case EVENT_MESSAGE: {
			PRINT_TOPIC("EVENT_MESSAGE", topic);
			struct SMessageEvent* evt = (struct SMessageEvent*)data;
			ret = circuit->Message(evt->player, evt->message);;
			break;
		}
		case EVENT_UNIT_CREATED: {
			PRINT_TOPIC("EVENT_UNIT_CREATED", topic);
			struct SUnitCreatedEvent* evt = (struct SUnitCreatedEvent*)data;
			CCircuitUnit* builder = (evt->builder < 0) ? nullptr : circuit->GetUnitById(evt->builder);
			CCircuitUnit* unit = circuit->RegisterUnit(evt->unit);
			ret = circuit->UnitCreated(unit, builder);
			break;
		}
		case EVENT_UNIT_FINISHED: {
			PRINT_TOPIC("EVENT_UNIT_FINISHED", topic);
			struct SUnitFinishedEvent* evt = (struct SUnitFinishedEvent*)data;
			// Lua might call SetUnitHealth within eventHandler.UnitCreated(this, builder);
			// and trigger UnitFinished before eoh->UnitCreated(*this, builder);
			// @see rts/Sim/Units/Unit.cpp CUnit::PostInit
			CCircuitUnit* unit = circuit->RegisterUnit(evt->unit);
			ret = circuit->UnitFinished(unit);
			break;
		}
		case EVENT_UNIT_IDLE: {
			PRINT_TOPIC("EVENT_UNIT_IDLE", topic);
			ret = 0;
			break;
		}
		case EVENT_UNIT_MOVE_FAILED: {
			PRINT_TOPIC("EVENT_UNIT_MOVE_FAILED", topic);
			ret = 0;
			break;
		}
		case EVENT_UNIT_DAMAGED: {
			PRINT_TOPIC("EVENT_UNIT_DAMAGED", topic);
			ret = 0;
			break;
		}
		case EVENT_UNIT_DESTROYED: {
			PRINT_TOPIC("EVENT_UNIT_DESTROYED", topic);
			struct SUnitDestroyedEvent* evt = (struct SUnitDestroyedEvent*)data;
			CCircuitUnit* attacker = circuit->GetUnitById(evt->attacker);
			CCircuitUnit* unit = circuit->GetUnitById(evt->unit);
			ret = circuit->UnitDestroyed(unit, attacker);
			circuit->UnregisterUnit(evt->unit);
			break;
		}
		case EVENT_UNIT_GIVEN: {
			PRINT_TOPIC("EVENT_UNIT_GIVEN", topic);
			ret = 0;
			break;
		}
		case EVENT_UNIT_CAPTURED: {
			PRINT_TOPIC("EVENT_UNIT_CAPTURED", topic);
			ret = 0;
			break;
		}
		case EVENT_ENEMY_ENTER_LOS: {
			PRINT_TOPIC("EVENT_ENEMY_ENTER_LOS", topic);
			ret = 0;
			break;
		}
		case EVENT_ENEMY_LEAVE_LOS: {
			PRINT_TOPIC("EVENT_ENEMY_LEAVE_LOS", topic);
			ret = 0;
			break;
		}
		case EVENT_ENEMY_ENTER_RADAR: {
			PRINT_TOPIC("EVENT_ENEMY_ENTER_RADAR", topic);
			ret = 0;
			break;
		}
		case EVENT_ENEMY_LEAVE_RADAR: {
			PRINT_TOPIC("EVENT_ENEMY_LEAVE_RADAR", topic);
			ret = 0;
			break;
		}
		case EVENT_ENEMY_DAMAGED: {
			PRINT_TOPIC("EVENT_ENEMY_DAMAGED", topic);
			ret = 0;
			break;
		}
		case EVENT_ENEMY_DESTROYED: {
			PRINT_TOPIC("EVENT_ENEMY_DESTROYED", topic);
			ret = 0;
			break;
		}
		case EVENT_WEAPON_FIRED: {
			PRINT_TOPIC("EVENT_WEAPON_FIRED", topic);
			ret = 0;
			break;
		}
		case EVENT_PLAYER_COMMAND: {
			PRINT_TOPIC("EVENT_PLAYER_COMMAND", topic);
			ret = 0;
			break;
		}
		case EVENT_SEISMIC_PING: {
			PRINT_TOPIC("EVENT_SEISMIC_PING", topic);
			ret = 0;
			break;
		}
		case EVENT_COMMAND_FINISHED: {
			PRINT_TOPIC("EVENT_COMMAND_FINISHED", topic);
			ret = 0;
			break;
		}
		case EVENT_LOAD: {
			PRINT_TOPIC("EVENT_LOAD", topic);
			ret = 0;
			break;
		}
		case EVENT_SAVE: {
			PRINT_TOPIC("EVENT_SAVE", topic);
			ret = 0;
			break;
		}
		case EVENT_ENEMY_CREATED: {
			PRINT_TOPIC("EVENT_ENEMY_CREATED", topic);
			ret = 0;
			break;
		}
		case EVENT_ENEMY_FINISHED: {
			PRINT_TOPIC("EVENT_ENEMY_FINISHED", topic);
			ret = 0;
			break;
		}
		case EVENT_LUA_MESSAGE: {
			PRINT_TOPIC("EVENT_LUA_MESSAGE", topic);
			struct SLuaMessageEvent* evt = (struct SLuaMessageEvent*)data;
			ret = circuit->LuaMessage(evt->inData);
			break;
		}
		default: {
			std::string msgText = std::string("<CircuitAI> warning topic: ") + utils::int_to_string(topic) + "  " + utils::int_to_string(callback->GetSkirmishAIId());
			springai::Log* log = callback->GetLog();
			log->DoLog(msgText.c_str());
			delete log;
			ret = 0;
			break;
		}
	}

	return ret;
}

} // namespace eventhandlerai
